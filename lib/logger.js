// Generated by CoffeeScript 1.10.0
(function() {
  var _error, _log, _warn, addTransport, contains, croak, debug, disable, enable, error, errorlet, isFunction, isTransportValid, logKeys, logLevel, logLevels, removeTransport, scream, setKeys, setLevel, speech, talk, transports, verbosityLevels, warn, whisper,
    slice = [].slice;

  errorlet = require('errorlet');

  logLevels = {
    debug: 2,
    warn: 4,
    error: 8
  };

  logLevel = logLevels.debug;

  logKeys = {};

  verbosityLevels = {
    whisper: 2,
    talk: 4,
    speech: 8,
    scream: 16
  };

  enable = function(key) {
    return logKeys[key] = new RegExp(key);
  };

  disable = function(key) {
    return delete logKeys[key];
  };

  setLevel = function(lvl) {
    if (logLevels.hasOwnProperty(lvl)) {
      return logLevel = logLevels[lvl];
    }
  };

  setKeys = function(keys) {
    var j, key, len;
    if (keys == null) {
      keys = [];
    }
    keys = keys instanceof Array ? keys : [keys];
    for (j = 0, len = keys.length; j < len; j++) {
      key = keys[j];
      enable(key);
    }
  };

  transports = [];

  contains = function(ary, item) {
    var j, len, x;
    for (j = 0, len = ary.length; j < len; j++) {
      x = ary[j];
      if (item === x) {
        return true;
      }
    }
    return false;
  };

  isFunction = function(func) {
    return typeof func === 'function' || func instanceof Function;
  };

  isTransportValid = function(logger) {
    return isFunction(logger.log) && isFunction(logger.warn) && isFunction(logger.error);
  };

  addTransport = function(logger) {
    if (isTransportValid(logger)) {
      if (!contains(transports, logger)) {
        return transports.push(logger);
      }
    } else {
      return errorlet.raise({
        error: 'loglet.invalid_transport',
        message: "must have .log, .warn, and .error function."
      });
    }
  };

  addTransport(console);

  removeTransport = function(logger) {
    var i, j, len, results, x;
    results = [];
    for (i = j = 0, len = transports.length; j < len; i = ++j) {
      x = transports[i];
      if (logger === x) {
        results.push(transports.splice(i, 1));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  _log = function() {
    var args, j, len, trans;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    for (j = 0, len = transports.length; j < len; j++) {
      trans = transports[j];
      trans.log.apply(trans, args);
    }
  };

  _warn = function() {
    var args, j, len, trans;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    for (j = 0, len = transports.length; j < len; j++) {
      trans = transports[j];
      trans.warn.apply(trans, args);
    }
  };

  _error = function() {
    var args, j, len, trans;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    for (j = 0, len = transports.length; j < len; j++) {
      trans = transports[j];
      trans.error.apply(trans, args);
    }
  };

  debug = function() {
    var args, k, key, regex;
    key = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (logLevel <= logLevels.debug) {
      for (k in logKeys) {
        regex = logKeys[k];
        if (key.match(regex)) {
          _log('DEBUG ----------', key, JSON.stringify(args, null, 2));
        }
      }
    }
  };

  whisper = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  };

  talk = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  };

  speech = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  };

  scream = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return _log.apply(null, args);
  };

  warn = function() {
    var arg, args, j, len, list;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (logLevel <= logLevels.warn) {
      list = [];
      list.push("*** WARN START ***\n");
      for (j = 0, len = args.length; j < len; j++) {
        arg = args[j];
        list.push(arg);
      }
      list.push("*** WARN END ***\n");
      _warn.apply(this, list);
    }
  };

  error = function() {
    var arg, args, j, len, list;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    list = [];
    list.push('****** ERROR START ******\n');
    for (j = 0, len = args.length; j < len; j++) {
      arg = args[j];
      list.push(arg);
      if (arg != null ? arg.stack : void 0) {
        list.push(arg.stack);
      }
    }
    list.push('****** ERROR END   ******\n');
    _error.apply(this, list);
  };

  croak = function() {
    var arg, args, code, j, len;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    error.apply(null, args);
    code = -1;
    for (j = 0, len = args.length; j < len; j++) {
      arg = args[j];
      if (arg != null ? arg.code : void 0) {
        code = arg.code;
      }
    }
    process.exit(code);
  };

  module.exports = {
    addTransport: addTransport,
    removeTransport: removeTransport,
    setLevel: setLevel,
    enable: enable,
    disable: disable,
    setKeys: setKeys,
    debug: debug,
    warn: warn,
    error: error,
    log: _log,
    whisper: whisper,
    talk: talk,
    speech: speech,
    scream: scream,
    croak: croak
  };

}).call(this);
